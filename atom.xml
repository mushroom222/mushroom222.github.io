<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>安那棋流放地</title>
  
  <subtitle>‘Who am I’</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-21T08:34:32.643Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Okey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++中的复制与拷贝构造函数</title>
    <link href="http://example.com/2021/03/21/c-%E4%B8%AD%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/03/21/c-%E4%B8%AD%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-21T06:50:14.000Z</published>
    <updated>2021-03-21T08:34:32.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="复制与拷贝构造函数"><a href="#复制与拷贝构造函数" class="headerlink" title="复制与拷贝构造函数"></a>复制与拷贝构造函数</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当我们想要修改一些变量时，我们会进行拷贝操作，但在许多时候，拷贝复制是不必要的，因为这些操作会占用额外的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector2 a=&#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    vector2 b=a;<span class="comment">//这里复制的是值，只是将a的内容赋给b</span></span><br><span class="line">    b.x=<span class="number">5</span>;<span class="comment">//当你修改b的值时，并不会改变a的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对类的操作还有另一种情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x,y;</span><br><span class="line">    vector2(<span class="keyword">int</span> a,<span class="keyword">int</span> b):x(a),y(b)&#123;&#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>*a=<span class="keyword">new</span> <span class="built_in">vector</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//使用new方式创见对象，a为指向对象的指针</span></span><br><span class="line">    vector2 *b=a;<span class="comment">//这里将a代表的内存地址复制给b</span></span><br><span class="line">    b-&gt;x=<span class="number">5</span>;<span class="comment">//当你修改b的值时，会同时修改a，b指向的内容，因为他们实际只想同一片内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h2><p>来写一个字符串类，使它具有可复制性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_Buffer;<span class="comment">//首先是创建一个字符数组</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_Size;<span class="comment">//然后保存它的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Size=<span class="built_in">strlen</span>(<span class="built_in">string</span>);<span class="comment">//使用strlen函数获取string的大小</span></span><br><span class="line">        m_Buffer =<span class="keyword">new</span> <span class="keyword">char</span>[m_Size+<span class="number">1</span>];<span class="comment">//预留一个位置储存休止符</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer,<span class="built_in">string</span>,m_Size);<span class="comment">//使用memcoy函数简洁的吧元素复制到m_Buffer中</span></span><br><span class="line">        <span class="comment">//memcoy(目标，来源，大小）</span></span><br><span class="line">        m_Buffer[m_Size]=<span class="number">0</span>;<span class="comment">//最后加上休止符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index)<span class="comment">//给String加上索引功能，这里没有安全检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; stream, <span class="keyword">const</span> String&amp; <span class="built_in">string</span>);<span class="comment">//进行友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; stream, <span class="keyword">const</span> String&amp; <span class="built_in">string</span>)<span class="comment">//重载左移运算符</span></span><br><span class="line">&#123;</span><br><span class="line">    stream&lt;&lt;<span class="built_in">string</span>.m_Buffer;<span class="comment">//现在可以访问类中的私有成员</span></span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String <span class="built_in">string</span> =<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来都很不错，事实上这个类缺少析构函数，有内存泄漏的危险，让我们加上一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_Buffer;<span class="comment">//首先是创建一个字符数组</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_Size;<span class="comment">//然后保存它的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Size=<span class="built_in">strlen</span>(<span class="built_in">string</span>);<span class="comment">//使用strlen函数获取string的大小</span></span><br><span class="line">        m_Buffer =<span class="keyword">new</span> <span class="keyword">char</span>[m_Size+<span class="number">1</span>];<span class="comment">//预留一个位置储存休止符</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_Buffer,<span class="built_in">string</span>,m_Size);<span class="comment">//使用memcoy函数简洁的吧元素复制到m_Buffer中</span></span><br><span class="line">        <span class="comment">//memcoy(目标，来源，大小）</span></span><br><span class="line">        m_Buffer[m_Size]=<span class="number">0</span>;<span class="comment">//最后加上休止符</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~String()<span class="comment">//加上析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_Buffer;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">unsigned</span> <span class="keyword">int</span> index)<span class="comment">//给String加上索引功能，这里没有安全检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Buffer[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; stream, <span class="keyword">const</span> String&amp; <span class="built_in">string</span>);<span class="comment">//进行友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; stream, <span class="keyword">const</span> String&amp; <span class="built_in">string</span>)<span class="comment">//重载左移运算符</span></span><br><span class="line">&#123;</span><br><span class="line">    stream&lt;&lt;<span class="built_in">string</span>.m_Buffer;<span class="comment">//现在可以访问类中的私有成员</span></span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String <span class="built_in">string</span> =<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来尝试复制String</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String <span class="built_in">string</span> =<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    String s1=<span class="built_in">string</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//运行到这里时一切正常，打出了两个hello</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当析构函数尝试运行时，程序崩溃了</span></span><br></pre></td></tr></table></figure><p>之前所做的操作在尝试复制一个类，当你复制一个类的时候，c++会将所有成员变量复制到一个新的内存地址，包括一个无符号类型和一个char*类型，所以程序实际复制了一个指针，两个类中的char指针指向相同的地址，但是析构函数调用了两次，尝试释放一片并不存在的内存，崩溃了</p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>上面的String类的复制方式并不好用，我们不想仅仅复制指针，而是开辟新的内存储存字符串的内容，这时就需要用到拷贝构造函数</p><p>c++会有一个默认拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">const</span> String&amp; other)</span><br><span class="line">    :m_Buffer(other.m_Buffer),m_Size(other.m_Size)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于刚才那个类差不多就是这样，默认构造函数刚才的使用过程中发现并不能满足要求，他只会默认复制指针</p><p>如果想要禁止对类对象进行复制操作，那么就像这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">const</span> String&amp; other)=<span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>现在来重写拷贝函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">const</span> String&amp; other):m_Size(other.m_Size)</span><br><span class="line">&#123;</span><br><span class="line">    m_Buffer=<span class="keyword">new</span> <span class="keyword">char</span>[m_Size+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_Buffer,other.m_Buffer,m_Size+<span class="number">1</span>);<span class="comment">//在最后加上休止符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你每次复制String时，都会调用拷贝函数，有些时候这没必要,这时候可以使用引用来避免复制，搭配const来避免不想被修改的数据被修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString</span><span class="params">(<span class="keyword">const</span> String&amp; <span class="built_in">string</span>)</span><span class="comment">//const和&amp;搭配使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分清对变量的复制与对地址指针的复制，当你不想复制时，使用const等方式来避免它</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://example.com/2021/03/20/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2021/03/20/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2021-03-20T07:47:39.000Z</published>
    <updated>2021-03-20T09:00:09.667Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="c-智能指针"><a href="#c-智能指针" class="headerlink" title="c++智能指针"></a>c++智能指针</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>智能指针是一种自动化操控内存的工具，有是你可以使用它们来代替new 和delete 进行更方便的内存控制操纵。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr是一个作用域指针，当程序运行超出范围时，它会自动销毁释放内存。所谓unique的意思就是你不能复制这种指针，当你复制它时，将会有两个指针指向同一片内存，如果其中一个销毁，它将会释放那片内存，另一个指针将会指向一片已经释放了的内存。</p><p>当你要使用==unique_ptr==时，加上==<memory>==头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Created Entity!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Destroyed Entity&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;<span class="comment">//我在作用域中初始化一个unique_ptr</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Entity&gt; entity1=<span class="built_in">std</span>::make_unique&lt;Entity&gt;();<span class="comment">//只是一种能检测构造函数异常的初始化方式，相对来说更安全</span></span><br><span class="line">        entity-&gt;function();<span class="comment">//现在他们能用普通指针的方式调用类中的数据和方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//但是当程序跳出上面的作用域时，指针将会自动销毁，析构函数将会运行打印&quot;Destroyed Entity&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr的工作方式是引用计数，它会追踪你的指针有多少个引用，一旦引用计数达到零。它就被删除了。当你创建一个shared_ptr,并且创建一个它的复制时，计数变为二，当这两个指针死亡时，计数归零，内存被释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Created Entity!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Destroyed Entity&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Entity&gt; e0;<span class="comment">//先在外层定义一个e0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在shared_ptr中使用make能够将分配Entity内存和分配储存引用计数内存的过程合二为一，相对于new关键字更有效率，而且能将new和delete关键字从你代码中驱逐出去</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Entity&gt; sharedEntity=<span class="built_in">std</span>::make_shared&lt;Entity&gt;();</span><br><span class="line">         e0=sharedEntity;<span class="comment">//能够对share_ptr进行复制，这对unique_ptr来说是非法的</span></span><br><span class="line">         entity-&gt;Print();<span class="comment">//类似的使用方式</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//当程序运行到这里超出内层作用域了，但析构函数并没有运行，因为e0仍然是活得,计数器仍不为0</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//当运行到这里时所有指针都死了，析构函数才会运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>你可以将一个shared_ptr赋给一个weak_ptr, 它的特别之处在于他不会增加引用计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Created Entity!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Entity()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Destroyed Entity&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;Entity&gt; e0;<span class="comment">//仅仅将这里换为weak_ptr</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在shared_ptr中使用make能够将分配Entity内存和分配储存引用计数内存的过程合二为一，相对于new关键字更有效率，而且能将new和delete关键字从你代码中驱逐出去</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Entity&gt; sharedEntity=<span class="built_in">std</span>::make_shared&lt;Entity&gt;();</span><br><span class="line">         e0=sharedEntity;<span class="comment">//能够对share_ptr进行复制，这对unique_ptr来说是非法的</span></span><br><span class="line">         entity-&gt;Print();<span class="comment">//类似的使用方式</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//当程序运行到这里超出内层作用域了，析构函数就会调用，因为只有内层的share指针会增加计数，当它死亡时，引用计数为0，将会释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之智能指针是一种提高内存控制能力的工具，当然也有一定的内存开销啦，但它们在现在的C++中还是挺好用的，这是我第一篇认真写的博客，目的是测试一下各种功能啦，总之明天见啦。<del>我去，在提交的过程中又出错了，一定记得加空格</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
